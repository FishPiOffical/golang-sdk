// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package fishPiSdk

import (
	"fmt"
	"strings"
)

const (
	// ChatroomMsgTypeOnline is a ChatroomMsgType of type online.
	// 在线
	ChatroomMsgTypeOnline ChatroomMsgType = "online"
	// ChatroomMsgTypeDiscussChanged is a ChatroomMsgType of type discussChanged.
	// 话题变更
	ChatroomMsgTypeDiscussChanged ChatroomMsgType = "discussChanged"
	// ChatroomMsgTypeRevoke is a ChatroomMsgType of type revoke.
	// 撤回
	ChatroomMsgTypeRevoke ChatroomMsgType = "revoke"
	// ChatroomMsgTypeMsg is a ChatroomMsgType of type msg.
	// 聊天
	ChatroomMsgTypeMsg ChatroomMsgType = "msg"
	// ChatroomMsgTypeRedPacketStatus is a ChatroomMsgType of type redPacketStatus.
	// 红包领取
	ChatroomMsgTypeRedPacketStatus ChatroomMsgType = "redPacketStatus"
	// ChatroomMsgTypeCustomMessage is a ChatroomMsgType of type customMessage.
	// 进入离开聊天室消息
	ChatroomMsgTypeCustomMessage ChatroomMsgType = "customMessage"
	// ChatroomMsgTypeBarrager is a ChatroomMsgType of type barrager.
	// 弹幕
	ChatroomMsgTypeBarrager ChatroomMsgType = "barrager"
)

var ErrInvalidChatroomMsgType = fmt.Errorf("not a valid ChatroomMsgType, try [%s]", strings.Join(_ChatroomMsgTypeNames, ", "))

var _ChatroomMsgTypeNames = []string{
	string(ChatroomMsgTypeOnline),
	string(ChatroomMsgTypeDiscussChanged),
	string(ChatroomMsgTypeRevoke),
	string(ChatroomMsgTypeMsg),
	string(ChatroomMsgTypeRedPacketStatus),
	string(ChatroomMsgTypeCustomMessage),
	string(ChatroomMsgTypeBarrager),
}

// ChatroomMsgTypeNames returns a list of possible string values of ChatroomMsgType.
func ChatroomMsgTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgTypeNames))
	copy(tmp, _ChatroomMsgTypeNames)
	return tmp
}

// ChatroomMsgTypeValues returns a list of the values for ChatroomMsgType
func ChatroomMsgTypeValues() []ChatroomMsgType {
	return []ChatroomMsgType{
		ChatroomMsgTypeOnline,
		ChatroomMsgTypeDiscussChanged,
		ChatroomMsgTypeRevoke,
		ChatroomMsgTypeMsg,
		ChatroomMsgTypeRedPacketStatus,
		ChatroomMsgTypeCustomMessage,
		ChatroomMsgTypeBarrager,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgType) IsValid() bool {
	_, err := ParseChatroomMsgType(string(x))
	return err == nil
}

var _ChatroomMsgTypeValue = map[string]ChatroomMsgType{
	"online":          ChatroomMsgTypeOnline,
	"discussChanged":  ChatroomMsgTypeDiscussChanged,
	"revoke":          ChatroomMsgTypeRevoke,
	"msg":             ChatroomMsgTypeMsg,
	"redPacketStatus": ChatroomMsgTypeRedPacketStatus,
	"customMessage":   ChatroomMsgTypeCustomMessage,
	"barrager":        ChatroomMsgTypeBarrager,
}

// ParseChatroomMsgType attempts to convert a string to a ChatroomMsgType.
func ParseChatroomMsgType(name string) (ChatroomMsgType, error) {
	if x, ok := _ChatroomMsgTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgType)
}

// MustParseChatroomMsgType converts a string to a ChatroomMsgType, and panics if is not valid.
func MustParseChatroomMsgType(name string) ChatroomMsgType {
	val, err := ParseChatroomMsgType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgType) Ptr() *ChatroomMsgType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomMsgType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomMsgType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomMsgType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomRedPacketTypeRandom is a ChatroomRedPacketType of type random.
	// 拼手气红包
	ChatroomRedPacketTypeRandom ChatroomRedPacketType = "random"
	// ChatroomRedPacketTypeAverage is a ChatroomRedPacketType of type average.
	// 平分红包
	ChatroomRedPacketTypeAverage ChatroomRedPacketType = "average"
	// ChatroomRedPacketTypeSpecify is a ChatroomRedPacketType of type specify.
	// 专属红包
	ChatroomRedPacketTypeSpecify ChatroomRedPacketType = "specify"
	// ChatroomRedPacketTypeHeartbeat is a ChatroomRedPacketType of type heartbeat.
	// 心跳红包
	ChatroomRedPacketTypeHeartbeat ChatroomRedPacketType = "heartbeat"
	// ChatroomRedPacketTypeRockPaperScissors is a ChatroomRedPacketType of type rockPaperScissors.
	// 猜拳红包
	ChatroomRedPacketTypeRockPaperScissors ChatroomRedPacketType = "rockPaperScissors"
)

var ErrInvalidChatroomRedPacketType = fmt.Errorf("not a valid ChatroomRedPacketType, try [%s]", strings.Join(_ChatroomRedPacketTypeNames, ", "))

var _ChatroomRedPacketTypeNames = []string{
	string(ChatroomRedPacketTypeRandom),
	string(ChatroomRedPacketTypeAverage),
	string(ChatroomRedPacketTypeSpecify),
	string(ChatroomRedPacketTypeHeartbeat),
	string(ChatroomRedPacketTypeRockPaperScissors),
}

// ChatroomRedPacketTypeNames returns a list of possible string values of ChatroomRedPacketType.
func ChatroomRedPacketTypeNames() []string {
	tmp := make([]string, len(_ChatroomRedPacketTypeNames))
	copy(tmp, _ChatroomRedPacketTypeNames)
	return tmp
}

// ChatroomRedPacketTypeValues returns a list of the values for ChatroomRedPacketType
func ChatroomRedPacketTypeValues() []ChatroomRedPacketType {
	return []ChatroomRedPacketType{
		ChatroomRedPacketTypeRandom,
		ChatroomRedPacketTypeAverage,
		ChatroomRedPacketTypeSpecify,
		ChatroomRedPacketTypeHeartbeat,
		ChatroomRedPacketTypeRockPaperScissors,
	}
}

// String implements the Stringer interface.
func (x ChatroomRedPacketType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomRedPacketType) IsValid() bool {
	_, err := ParseChatroomRedPacketType(string(x))
	return err == nil
}

var _ChatroomRedPacketTypeValue = map[string]ChatroomRedPacketType{
	"random":            ChatroomRedPacketTypeRandom,
	"average":           ChatroomRedPacketTypeAverage,
	"specify":           ChatroomRedPacketTypeSpecify,
	"heartbeat":         ChatroomRedPacketTypeHeartbeat,
	"rockPaperScissors": ChatroomRedPacketTypeRockPaperScissors,
}

// ParseChatroomRedPacketType attempts to convert a string to a ChatroomRedPacketType.
func ParseChatroomRedPacketType(name string) (ChatroomRedPacketType, error) {
	if x, ok := _ChatroomRedPacketTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomRedPacketType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomRedPacketType)
}

// MustParseChatroomRedPacketType converts a string to a ChatroomRedPacketType, and panics if is not valid.
func MustParseChatroomRedPacketType(name string) ChatroomRedPacketType {
	val, err := ParseChatroomRedPacketType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomRedPacketType) Ptr() *ChatroomRedPacketType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomRedPacketType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomRedPacketType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomRedPacketType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GestureTypeRock is a GestureType of type Rock.
	// 石头
	GestureTypeRock GestureType = iota
	// GestureTypeScissors is a GestureType of type Scissors.
	// 剪刀
	GestureTypeScissors
	// GestureTypePaper is a GestureType of type Paper.
	// 布
	GestureTypePaper
)

var ErrInvalidGestureType = fmt.Errorf("not a valid GestureType, try [%s]", strings.Join(_GestureTypeNames, ", "))

const _GestureTypeName = "rockscissorspaper"

var _GestureTypeNames = []string{
	_GestureTypeName[0:4],
	_GestureTypeName[4:12],
	_GestureTypeName[12:17],
}

// GestureTypeNames returns a list of possible string values of GestureType.
func GestureTypeNames() []string {
	tmp := make([]string, len(_GestureTypeNames))
	copy(tmp, _GestureTypeNames)
	return tmp
}

// GestureTypeValues returns a list of the values for GestureType
func GestureTypeValues() []GestureType {
	return []GestureType{
		GestureTypeRock,
		GestureTypeScissors,
		GestureTypePaper,
	}
}

var _GestureTypeMap = map[GestureType]string{
	GestureTypeRock:     _GestureTypeName[0:4],
	GestureTypeScissors: _GestureTypeName[4:12],
	GestureTypePaper:    _GestureTypeName[12:17],
}

// String implements the Stringer interface.
func (x GestureType) String() string {
	if str, ok := _GestureTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("GestureType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GestureType) IsValid() bool {
	_, ok := _GestureTypeMap[x]
	return ok
}

var _GestureTypeValue = map[string]GestureType{
	_GestureTypeName[0:4]:   GestureTypeRock,
	_GestureTypeName[4:12]:  GestureTypeScissors,
	_GestureTypeName[12:17]: GestureTypePaper,
}

// ParseGestureType attempts to convert a string to a GestureType.
func ParseGestureType(name string) (GestureType, error) {
	if x, ok := _GestureTypeValue[name]; ok {
		return x, nil
	}
	return GestureType(0), fmt.Errorf("%s is %w", name, ErrInvalidGestureType)
}

// MustParseGestureType converts a string to a GestureType, and panics if is not valid.
func MustParseGestureType(name string) GestureType {
	val, err := ParseGestureType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x GestureType) Ptr() *GestureType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x GestureType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *GestureType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGestureType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NotificationTypePoint is a NotificationType of type point.
	// 积分
	NotificationTypePoint NotificationType = "point"
	// NotificationTypeCommented is a NotificationType of type commented.
	// 收到的回帖
	NotificationTypeCommented NotificationType = "commented"
	// NotificationTypeReply is a NotificationType of type reply.
	// 收到的回复
	NotificationTypeReply NotificationType = "reply"
	// NotificationTypeAt is a NotificationType of type at.
	// 提及我的
	NotificationTypeAt NotificationType = "at"
	// NotificationTypeFollowing is a NotificationType of type following.
	// 我关注的
	NotificationTypeFollowing NotificationType = "following"
	// NotificationTypeBroadcast is a NotificationType of type broadcast.
	// 同城
	NotificationTypeBroadcast NotificationType = "broadcast"
	// NotificationTypeSysAnnounce is a NotificationType of type sys-announce.
	// 系统
	NotificationTypeSysAnnounce NotificationType = "sys-announce"
)

var ErrInvalidNotificationType = fmt.Errorf("not a valid NotificationType, try [%s]", strings.Join(_NotificationTypeNames, ", "))

var _NotificationTypeNames = []string{
	string(NotificationTypePoint),
	string(NotificationTypeCommented),
	string(NotificationTypeReply),
	string(NotificationTypeAt),
	string(NotificationTypeFollowing),
	string(NotificationTypeBroadcast),
	string(NotificationTypeSysAnnounce),
}

// NotificationTypeNames returns a list of possible string values of NotificationType.
func NotificationTypeNames() []string {
	tmp := make([]string, len(_NotificationTypeNames))
	copy(tmp, _NotificationTypeNames)
	return tmp
}

// NotificationTypeValues returns a list of the values for NotificationType
func NotificationTypeValues() []NotificationType {
	return []NotificationType{
		NotificationTypePoint,
		NotificationTypeCommented,
		NotificationTypeReply,
		NotificationTypeAt,
		NotificationTypeFollowing,
		NotificationTypeBroadcast,
		NotificationTypeSysAnnounce,
	}
}

// String implements the Stringer interface.
func (x NotificationType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NotificationType) IsValid() bool {
	_, err := ParseNotificationType(string(x))
	return err == nil
}

var _NotificationTypeValue = map[string]NotificationType{
	"point":        NotificationTypePoint,
	"commented":    NotificationTypeCommented,
	"reply":        NotificationTypeReply,
	"at":           NotificationTypeAt,
	"following":    NotificationTypeFollowing,
	"broadcast":    NotificationTypeBroadcast,
	"sys-announce": NotificationTypeSysAnnounce,
}

// ParseNotificationType attempts to convert a string to a NotificationType.
func ParseNotificationType(name string) (NotificationType, error) {
	if x, ok := _NotificationTypeValue[name]; ok {
		return x, nil
	}
	return NotificationType(""), fmt.Errorf("%s is %w", name, ErrInvalidNotificationType)
}

// MustParseNotificationType converts a string to a NotificationType, and panics if is not valid.
func MustParseNotificationType(name string) NotificationType {
	val, err := ParseNotificationType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x NotificationType) Ptr() *NotificationType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x NotificationType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NotificationType) UnmarshalText(text []byte) error {
	tmp, err := ParseNotificationType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
