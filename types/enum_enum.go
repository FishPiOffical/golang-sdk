// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// ArticleListTypeHot is a ArticleListType of type hot.
	ArticleListTypeHot ArticleListType = "hot"
	// ArticleListTypeGood is a ArticleListType of type good.
	ArticleListTypeGood ArticleListType = "good"
	// ArticleListTypePerfect is a ArticleListType of type perfect.
	ArticleListTypePerfect ArticleListType = "perfect"
	// ArticleListTypeReply is a ArticleListType of type reply.
	ArticleListTypeReply ArticleListType = "reply"
)

var ErrInvalidArticleListType = fmt.Errorf("not a valid ArticleListType, try [%s]", strings.Join(_ArticleListTypeNames, ", "))

var _ArticleListTypeNames = []string{
	string(ArticleListTypeHot),
	string(ArticleListTypeGood),
	string(ArticleListTypePerfect),
	string(ArticleListTypeReply),
}

// ArticleListTypeNames returns a list of possible string values of ArticleListType.
func ArticleListTypeNames() []string {
	tmp := make([]string, len(_ArticleListTypeNames))
	copy(tmp, _ArticleListTypeNames)
	return tmp
}

// ArticleListTypeValues returns a list of the values for ArticleListType
func ArticleListTypeValues() []ArticleListType {
	return []ArticleListType{
		ArticleListTypeHot,
		ArticleListTypeGood,
		ArticleListTypePerfect,
		ArticleListTypeReply,
	}
}

// String implements the Stringer interface.
func (x ArticleListType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleListType) IsValid() bool {
	_, err := ParseArticleListType(string(x))
	return err == nil
}

var _ArticleListTypeValue = map[string]ArticleListType{
	"hot":     ArticleListTypeHot,
	"good":    ArticleListTypeGood,
	"perfect": ArticleListTypePerfect,
	"reply":   ArticleListTypeReply,
}

// ParseArticleListType attempts to convert a string to a ArticleListType.
func ParseArticleListType(name string) (ArticleListType, error) {
	if x, ok := _ArticleListTypeValue[name]; ok {
		return x, nil
	}
	return ArticleListType(""), fmt.Errorf("%s is %w", name, ErrInvalidArticleListType)
}

// MustParseArticleListType converts a string to a ArticleListType, and panics if is not valid.
func MustParseArticleListType(name string) ArticleListType {
	val, err := ParseArticleListType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleListType) Ptr() *ArticleListType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticleListType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticleListType) UnmarshalText(text []byte) error {
	tmp, err := ParseArticleListType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatContentTypeMd is a ChatContentType of type md.
	// Markdown
	ChatContentTypeMd ChatContentType = "md"
	// ChatContentTypeHtml is a ChatContentType of type html.
	// HTML
	ChatContentTypeHtml ChatContentType = "html"
)

var ErrInvalidChatContentType = fmt.Errorf("not a valid ChatContentType, try [%s]", strings.Join(_ChatContentTypeNames, ", "))

var _ChatContentTypeNames = []string{
	string(ChatContentTypeMd),
	string(ChatContentTypeHtml),
}

// ChatContentTypeNames returns a list of possible string values of ChatContentType.
func ChatContentTypeNames() []string {
	tmp := make([]string, len(_ChatContentTypeNames))
	copy(tmp, _ChatContentTypeNames)
	return tmp
}

// ChatContentTypeValues returns a list of the values for ChatContentType
func ChatContentTypeValues() []ChatContentType {
	return []ChatContentType{
		ChatContentTypeMd,
		ChatContentTypeHtml,
	}
}

// String implements the Stringer interface.
func (x ChatContentType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatContentType) IsValid() bool {
	_, err := ParseChatContentType(string(x))
	return err == nil
}

var _ChatContentTypeValue = map[string]ChatContentType{
	"md":   ChatContentTypeMd,
	"html": ChatContentTypeHtml,
}

// ParseChatContentType attempts to convert a string to a ChatContentType.
func ParseChatContentType(name string) (ChatContentType, error) {
	if x, ok := _ChatContentTypeValue[name]; ok {
		return x, nil
	}
	return ChatContentType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatContentType)
}

// MustParseChatContentType converts a string to a ChatContentType, and panics if is not valid.
func MustParseChatContentType(name string) ChatContentType {
	val, err := ParseChatContentType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatContentType) Ptr() *ChatContentType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatContentType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatContentType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatContentType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatMessageTypeContext is a ChatMessageType of type Context.
	// 上下文
	ChatMessageTypeContext ChatMessageType = iota
	// ChatMessageTypeBefore is a ChatMessageType of type Before.
	// 之前
	ChatMessageTypeBefore
	// ChatMessageTypeAfter is a ChatMessageType of type After.
	// 之后
	ChatMessageTypeAfter
)

var ErrInvalidChatMessageType = fmt.Errorf("not a valid ChatMessageType, try [%s]", strings.Join(_ChatMessageTypeNames, ", "))

const _ChatMessageTypeName = "contextbeforeafter"

var _ChatMessageTypeNames = []string{
	_ChatMessageTypeName[0:7],
	_ChatMessageTypeName[7:13],
	_ChatMessageTypeName[13:18],
}

// ChatMessageTypeNames returns a list of possible string values of ChatMessageType.
func ChatMessageTypeNames() []string {
	tmp := make([]string, len(_ChatMessageTypeNames))
	copy(tmp, _ChatMessageTypeNames)
	return tmp
}

// ChatMessageTypeValues returns a list of the values for ChatMessageType
func ChatMessageTypeValues() []ChatMessageType {
	return []ChatMessageType{
		ChatMessageTypeContext,
		ChatMessageTypeBefore,
		ChatMessageTypeAfter,
	}
}

var _ChatMessageTypeMap = map[ChatMessageType]string{
	ChatMessageTypeContext: _ChatMessageTypeName[0:7],
	ChatMessageTypeBefore:  _ChatMessageTypeName[7:13],
	ChatMessageTypeAfter:   _ChatMessageTypeName[13:18],
}

// String implements the Stringer interface.
func (x ChatMessageType) String() string {
	if str, ok := _ChatMessageTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ChatMessageType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatMessageType) IsValid() bool {
	_, ok := _ChatMessageTypeMap[x]
	return ok
}

var _ChatMessageTypeValue = map[string]ChatMessageType{
	_ChatMessageTypeName[0:7]:   ChatMessageTypeContext,
	_ChatMessageTypeName[7:13]:  ChatMessageTypeBefore,
	_ChatMessageTypeName[13:18]: ChatMessageTypeAfter,
}

// ParseChatMessageType attempts to convert a string to a ChatMessageType.
func ParseChatMessageType(name string) (ChatMessageType, error) {
	if x, ok := _ChatMessageTypeValue[name]; ok {
		return x, nil
	}
	return ChatMessageType(0), fmt.Errorf("%s is %w", name, ErrInvalidChatMessageType)
}

// MustParseChatMessageType converts a string to a ChatMessageType, and panics if is not valid.
func MustParseChatMessageType(name string) ChatMessageType {
	val, err := ParseChatMessageType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatMessageType) Ptr() *ChatMessageType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatMessageType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatMessageType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseChatMessageType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomMsgTypeOnline is a ChatroomMsgType of type online.
	// 在线
	ChatroomMsgTypeOnline ChatroomMsgType = "online"
	// ChatroomMsgTypeDiscussChanged is a ChatroomMsgType of type discussChanged.
	// 话题变更
	ChatroomMsgTypeDiscussChanged ChatroomMsgType = "discussChanged"
	// ChatroomMsgTypeRevoke is a ChatroomMsgType of type revoke.
	// 撤回
	ChatroomMsgTypeRevoke ChatroomMsgType = "revoke"
	// ChatroomMsgTypeMsg is a ChatroomMsgType of type msg.
	// 聊天
	ChatroomMsgTypeMsg ChatroomMsgType = "msg"
	// ChatroomMsgTypeRedPacket is a ChatroomMsgType of type redPacket.
	// 红包
	ChatroomMsgTypeRedPacket ChatroomMsgType = "redPacket"
	// ChatroomMsgTypeRedPacketStatus is a ChatroomMsgType of type redPacketStatus.
	// 红包领取
	ChatroomMsgTypeRedPacketStatus ChatroomMsgType = "redPacketStatus"
	// ChatroomMsgTypeCustomMessage is a ChatroomMsgType of type customMessage.
	// 进入离开聊天室消息
	ChatroomMsgTypeCustomMessage ChatroomMsgType = "customMessage"
	// ChatroomMsgTypeBarrager is a ChatroomMsgType of type barrager.
	// 弹幕
	ChatroomMsgTypeBarrager ChatroomMsgType = "barrager"
)

var ErrInvalidChatroomMsgType = fmt.Errorf("not a valid ChatroomMsgType, try [%s]", strings.Join(_ChatroomMsgTypeNames, ", "))

var _ChatroomMsgTypeNames = []string{
	string(ChatroomMsgTypeOnline),
	string(ChatroomMsgTypeDiscussChanged),
	string(ChatroomMsgTypeRevoke),
	string(ChatroomMsgTypeMsg),
	string(ChatroomMsgTypeRedPacket),
	string(ChatroomMsgTypeRedPacketStatus),
	string(ChatroomMsgTypeCustomMessage),
	string(ChatroomMsgTypeBarrager),
}

// ChatroomMsgTypeNames returns a list of possible string values of ChatroomMsgType.
func ChatroomMsgTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgTypeNames))
	copy(tmp, _ChatroomMsgTypeNames)
	return tmp
}

// ChatroomMsgTypeValues returns a list of the values for ChatroomMsgType
func ChatroomMsgTypeValues() []ChatroomMsgType {
	return []ChatroomMsgType{
		ChatroomMsgTypeOnline,
		ChatroomMsgTypeDiscussChanged,
		ChatroomMsgTypeRevoke,
		ChatroomMsgTypeMsg,
		ChatroomMsgTypeRedPacket,
		ChatroomMsgTypeRedPacketStatus,
		ChatroomMsgTypeCustomMessage,
		ChatroomMsgTypeBarrager,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgType) IsValid() bool {
	_, err := ParseChatroomMsgType(string(x))
	return err == nil
}

var _ChatroomMsgTypeValue = map[string]ChatroomMsgType{
	"online":          ChatroomMsgTypeOnline,
	"discussChanged":  ChatroomMsgTypeDiscussChanged,
	"revoke":          ChatroomMsgTypeRevoke,
	"msg":             ChatroomMsgTypeMsg,
	"redPacket":       ChatroomMsgTypeRedPacket,
	"redPacketStatus": ChatroomMsgTypeRedPacketStatus,
	"customMessage":   ChatroomMsgTypeCustomMessage,
	"barrager":        ChatroomMsgTypeBarrager,
}

// ParseChatroomMsgType attempts to convert a string to a ChatroomMsgType.
func ParseChatroomMsgType(name string) (ChatroomMsgType, error) {
	if x, ok := _ChatroomMsgTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgType)
}

// MustParseChatroomMsgType converts a string to a ChatroomMsgType, and panics if is not valid.
func MustParseChatroomMsgType(name string) ChatroomMsgType {
	val, err := ParseChatroomMsgType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgType) Ptr() *ChatroomMsgType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomMsgType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomMsgType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomMsgType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomRedPacketTypeRandom is a ChatroomRedPacketType of type random.
	// 拼手气红包
	ChatroomRedPacketTypeRandom ChatroomRedPacketType = "random"
	// ChatroomRedPacketTypeAverage is a ChatroomRedPacketType of type average.
	// 平分红包
	ChatroomRedPacketTypeAverage ChatroomRedPacketType = "average"
	// ChatroomRedPacketTypeSpecify is a ChatroomRedPacketType of type specify.
	// 专属红包
	ChatroomRedPacketTypeSpecify ChatroomRedPacketType = "specify"
	// ChatroomRedPacketTypeHeartbeat is a ChatroomRedPacketType of type heartbeat.
	// 心跳红包
	ChatroomRedPacketTypeHeartbeat ChatroomRedPacketType = "heartbeat"
	// ChatroomRedPacketTypeRockPaperScissors is a ChatroomRedPacketType of type rockPaperScissors.
	// 猜拳红包
	ChatroomRedPacketTypeRockPaperScissors ChatroomRedPacketType = "rockPaperScissors"
)

var ErrInvalidChatroomRedPacketType = fmt.Errorf("not a valid ChatroomRedPacketType, try [%s]", strings.Join(_ChatroomRedPacketTypeNames, ", "))

var _ChatroomRedPacketTypeNames = []string{
	string(ChatroomRedPacketTypeRandom),
	string(ChatroomRedPacketTypeAverage),
	string(ChatroomRedPacketTypeSpecify),
	string(ChatroomRedPacketTypeHeartbeat),
	string(ChatroomRedPacketTypeRockPaperScissors),
}

// ChatroomRedPacketTypeNames returns a list of possible string values of ChatroomRedPacketType.
func ChatroomRedPacketTypeNames() []string {
	tmp := make([]string, len(_ChatroomRedPacketTypeNames))
	copy(tmp, _ChatroomRedPacketTypeNames)
	return tmp
}

// ChatroomRedPacketTypeValues returns a list of the values for ChatroomRedPacketType
func ChatroomRedPacketTypeValues() []ChatroomRedPacketType {
	return []ChatroomRedPacketType{
		ChatroomRedPacketTypeRandom,
		ChatroomRedPacketTypeAverage,
		ChatroomRedPacketTypeSpecify,
		ChatroomRedPacketTypeHeartbeat,
		ChatroomRedPacketTypeRockPaperScissors,
	}
}

// String implements the Stringer interface.
func (x ChatroomRedPacketType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomRedPacketType) IsValid() bool {
	_, err := ParseChatroomRedPacketType(string(x))
	return err == nil
}

var _ChatroomRedPacketTypeValue = map[string]ChatroomRedPacketType{
	"random":            ChatroomRedPacketTypeRandom,
	"average":           ChatroomRedPacketTypeAverage,
	"specify":           ChatroomRedPacketTypeSpecify,
	"heartbeat":         ChatroomRedPacketTypeHeartbeat,
	"rockPaperScissors": ChatroomRedPacketTypeRockPaperScissors,
}

// ParseChatroomRedPacketType attempts to convert a string to a ChatroomRedPacketType.
func ParseChatroomRedPacketType(name string) (ChatroomRedPacketType, error) {
	if x, ok := _ChatroomRedPacketTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomRedPacketType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomRedPacketType)
}

// MustParseChatroomRedPacketType converts a string to a ChatroomRedPacketType, and panics if is not valid.
func MustParseChatroomRedPacketType(name string) ChatroomRedPacketType {
	val, err := ParseChatroomRedPacketType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomRedPacketType) Ptr() *ChatroomRedPacketType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomRedPacketType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomRedPacketType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomRedPacketType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// GestureTypeRock is a GestureType of type Rock.
	// 石头
	GestureTypeRock GestureType = iota
	// GestureTypeScissors is a GestureType of type Scissors.
	// 剪刀
	GestureTypeScissors
	// GestureTypePaper is a GestureType of type Paper.
	// 布
	GestureTypePaper
)

var ErrInvalidGestureType = fmt.Errorf("not a valid GestureType, try [%s]", strings.Join(_GestureTypeNames, ", "))

const _GestureTypeName = "rockscissorspaper"

var _GestureTypeNames = []string{
	_GestureTypeName[0:4],
	_GestureTypeName[4:12],
	_GestureTypeName[12:17],
}

// GestureTypeNames returns a list of possible string values of GestureType.
func GestureTypeNames() []string {
	tmp := make([]string, len(_GestureTypeNames))
	copy(tmp, _GestureTypeNames)
	return tmp
}

// GestureTypeValues returns a list of the values for GestureType
func GestureTypeValues() []GestureType {
	return []GestureType{
		GestureTypeRock,
		GestureTypeScissors,
		GestureTypePaper,
	}
}

var _GestureTypeMap = map[GestureType]string{
	GestureTypeRock:     _GestureTypeName[0:4],
	GestureTypeScissors: _GestureTypeName[4:12],
	GestureTypePaper:    _GestureTypeName[12:17],
}

// String implements the Stringer interface.
func (x GestureType) String() string {
	if str, ok := _GestureTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("GestureType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GestureType) IsValid() bool {
	_, ok := _GestureTypeMap[x]
	return ok
}

var _GestureTypeValue = map[string]GestureType{
	_GestureTypeName[0:4]:   GestureTypeRock,
	_GestureTypeName[4:12]:  GestureTypeScissors,
	_GestureTypeName[12:17]: GestureTypePaper,
}

// ParseGestureType attempts to convert a string to a GestureType.
func ParseGestureType(name string) (GestureType, error) {
	if x, ok := _GestureTypeValue[name]; ok {
		return x, nil
	}
	return GestureType(0), fmt.Errorf("%s is %w", name, ErrInvalidGestureType)
}

// MustParseGestureType converts a string to a GestureType, and panics if is not valid.
func MustParseGestureType(name string) GestureType {
	val, err := ParseGestureType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x GestureType) Ptr() *GestureType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x GestureType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *GestureType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseGestureType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// NotificationTypePoint is a NotificationType of type point.
	// 积分
	NotificationTypePoint NotificationType = "point"
	// NotificationTypeCommented is a NotificationType of type commented.
	// 收到的回帖
	NotificationTypeCommented NotificationType = "commented"
	// NotificationTypeReply is a NotificationType of type reply.
	// 收到的回复
	NotificationTypeReply NotificationType = "reply"
	// NotificationTypeAt is a NotificationType of type at.
	// 提及我的
	NotificationTypeAt NotificationType = "at"
	// NotificationTypeFollowing is a NotificationType of type following.
	// 我关注的
	NotificationTypeFollowing NotificationType = "following"
	// NotificationTypeBroadcast is a NotificationType of type broadcast.
	// 同城
	NotificationTypeBroadcast NotificationType = "broadcast"
	// NotificationTypeSysAnnounce is a NotificationType of type sys-announce.
	// 系统
	NotificationTypeSysAnnounce NotificationType = "sys-announce"
)

var ErrInvalidNotificationType = fmt.Errorf("not a valid NotificationType, try [%s]", strings.Join(_NotificationTypeNames, ", "))

var _NotificationTypeNames = []string{
	string(NotificationTypePoint),
	string(NotificationTypeCommented),
	string(NotificationTypeReply),
	string(NotificationTypeAt),
	string(NotificationTypeFollowing),
	string(NotificationTypeBroadcast),
	string(NotificationTypeSysAnnounce),
}

// NotificationTypeNames returns a list of possible string values of NotificationType.
func NotificationTypeNames() []string {
	tmp := make([]string, len(_NotificationTypeNames))
	copy(tmp, _NotificationTypeNames)
	return tmp
}

// NotificationTypeValues returns a list of the values for NotificationType
func NotificationTypeValues() []NotificationType {
	return []NotificationType{
		NotificationTypePoint,
		NotificationTypeCommented,
		NotificationTypeReply,
		NotificationTypeAt,
		NotificationTypeFollowing,
		NotificationTypeBroadcast,
		NotificationTypeSysAnnounce,
	}
}

// String implements the Stringer interface.
func (x NotificationType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x NotificationType) IsValid() bool {
	_, err := ParseNotificationType(string(x))
	return err == nil
}

var _NotificationTypeValue = map[string]NotificationType{
	"point":        NotificationTypePoint,
	"commented":    NotificationTypeCommented,
	"reply":        NotificationTypeReply,
	"at":           NotificationTypeAt,
	"following":    NotificationTypeFollowing,
	"broadcast":    NotificationTypeBroadcast,
	"sys-announce": NotificationTypeSysAnnounce,
}

// ParseNotificationType attempts to convert a string to a NotificationType.
func ParseNotificationType(name string) (NotificationType, error) {
	if x, ok := _NotificationTypeValue[name]; ok {
		return x, nil
	}
	return NotificationType(""), fmt.Errorf("%s is %w", name, ErrInvalidNotificationType)
}

// MustParseNotificationType converts a string to a NotificationType, and panics if is not valid.
func MustParseNotificationType(name string) NotificationType {
	val, err := ParseNotificationType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x NotificationType) Ptr() *NotificationType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x NotificationType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NotificationType) UnmarshalText(text []byte) error {
	tmp, err := ParseNotificationType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// VoteTypeUnVote is a VoteType of type UnVote.
	// 未投票
	VoteTypeUnVote VoteType = iota + -1
	// VoteTypeVoted is a VoteType of type Voted.
	// 点赞
	VoteTypeVoted
)

var ErrInvalidVoteType = fmt.Errorf("not a valid VoteType, try [%s]", strings.Join(_VoteTypeNames, ", "))

const _VoteTypeName = "unVotevoted"

var _VoteTypeNames = []string{
	_VoteTypeName[0:6],
	_VoteTypeName[6:11],
}

// VoteTypeNames returns a list of possible string values of VoteType.
func VoteTypeNames() []string {
	tmp := make([]string, len(_VoteTypeNames))
	copy(tmp, _VoteTypeNames)
	return tmp
}

// VoteTypeValues returns a list of the values for VoteType
func VoteTypeValues() []VoteType {
	return []VoteType{
		VoteTypeUnVote,
		VoteTypeVoted,
	}
}

var _VoteTypeMap = map[VoteType]string{
	VoteTypeUnVote: _VoteTypeName[0:6],
	VoteTypeVoted:  _VoteTypeName[6:11],
}

// String implements the Stringer interface.
func (x VoteType) String() string {
	if str, ok := _VoteTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("VoteType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VoteType) IsValid() bool {
	_, ok := _VoteTypeMap[x]
	return ok
}

var _VoteTypeValue = map[string]VoteType{
	_VoteTypeName[0:6]:  VoteTypeUnVote,
	_VoteTypeName[6:11]: VoteTypeVoted,
}

// ParseVoteType attempts to convert a string to a VoteType.
func ParseVoteType(name string) (VoteType, error) {
	if x, ok := _VoteTypeValue[name]; ok {
		return x, nil
	}
	return VoteType(0), fmt.Errorf("%s is %w", name, ErrInvalidVoteType)
}

// MustParseVoteType converts a string to a VoteType, and panics if is not valid.
func MustParseVoteType(name string) VoteType {
	val, err := ParseVoteType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x VoteType) Ptr() *VoteType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x VoteType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *VoteType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVoteType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
