// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// ArticleListTypeHot is a ArticleListType of type hot.
	// 热门
	ArticleListTypeHot ArticleListType = "hot"
	// ArticleListTypeGood is a ArticleListType of type good.
	// 精华
	ArticleListTypeGood ArticleListType = "good"
	// ArticleListTypePerfect is a ArticleListType of type perfect.
	// 精选
	ArticleListTypePerfect ArticleListType = "perfect"
	// ArticleListTypeReply is a ArticleListType of type reply.
	// 回复
	ArticleListTypeReply ArticleListType = "reply"
)

var ErrInvalidArticleListType = fmt.Errorf("not a valid ArticleListType, try [%s]", strings.Join(_ArticleListTypeNames, ", "))

var _ArticleListTypeNames = []string{
	string(ArticleListTypeHot),
	string(ArticleListTypeGood),
	string(ArticleListTypePerfect),
	string(ArticleListTypeReply),
}

// ArticleListTypeNames returns a list of possible string values of ArticleListType.
func ArticleListTypeNames() []string {
	tmp := make([]string, len(_ArticleListTypeNames))
	copy(tmp, _ArticleListTypeNames)
	return tmp
}

// ArticleListTypeValues returns a list of the values for ArticleListType
func ArticleListTypeValues() []ArticleListType {
	return []ArticleListType{
		ArticleListTypeHot,
		ArticleListTypeGood,
		ArticleListTypePerfect,
		ArticleListTypeReply,
	}
}

// String implements the Stringer interface.
func (x ArticleListType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleListType) IsValid() bool {
	_, err := ParseArticleListType(string(x))
	return err == nil
}

var _ArticleListTypeValue = map[string]ArticleListType{
	"hot":     ArticleListTypeHot,
	"good":    ArticleListTypeGood,
	"perfect": ArticleListTypePerfect,
	"reply":   ArticleListTypeReply,
}

// ParseArticleListType attempts to convert a string to a ArticleListType.
func ParseArticleListType(name string) (ArticleListType, error) {
	if x, ok := _ArticleListTypeValue[name]; ok {
		return x, nil
	}
	return ArticleListType(""), fmt.Errorf("%s is %w", name, ErrInvalidArticleListType)
}

// MustParseArticleListType converts a string to a ArticleListType, and panics if is not valid.
func MustParseArticleListType(name string) ArticleListType {
	val, err := ParseArticleListType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleListType) Ptr() *ArticleListType {
	return &x
}

const (
	// ArticlePerfectYes is a ArticlePerfect of type Yes.
	// 是
	ArticlePerfectYes ArticlePerfect = iota + 1
	// ArticlePerfectNo is a ArticlePerfect of type No.
	// 否
	ArticlePerfectNo ArticlePerfect = iota + -1
)

var ErrInvalidArticlePerfect = fmt.Errorf("not a valid ArticlePerfect, try [%s]", strings.Join(_ArticlePerfectNames, ", "))

const _ArticlePerfectName = "yesno"

var _ArticlePerfectNames = []string{
	_ArticlePerfectName[0:3],
	_ArticlePerfectName[3:5],
}

// ArticlePerfectNames returns a list of possible string values of ArticlePerfect.
func ArticlePerfectNames() []string {
	tmp := make([]string, len(_ArticlePerfectNames))
	copy(tmp, _ArticlePerfectNames)
	return tmp
}

// ArticlePerfectValues returns a list of the values for ArticlePerfect
func ArticlePerfectValues() []ArticlePerfect {
	return []ArticlePerfect{
		ArticlePerfectYes,
		ArticlePerfectNo,
	}
}

var _ArticlePerfectMap = map[ArticlePerfect]string{
	ArticlePerfectYes: _ArticlePerfectName[0:3],
	ArticlePerfectNo:  _ArticlePerfectName[3:5],
}

// String implements the Stringer interface.
func (x ArticlePerfect) String() string {
	if str, ok := _ArticlePerfectMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ArticlePerfect(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticlePerfect) IsValid() bool {
	_, ok := _ArticlePerfectMap[x]
	return ok
}

var _ArticlePerfectValue = map[string]ArticlePerfect{
	_ArticlePerfectName[0:3]: ArticlePerfectYes,
	_ArticlePerfectName[3:5]: ArticlePerfectNo,
}

// ParseArticlePerfect attempts to convert a string to a ArticlePerfect.
func ParseArticlePerfect(name string) (ArticlePerfect, error) {
	if x, ok := _ArticlePerfectValue[name]; ok {
		return x, nil
	}
	return ArticlePerfect(0), fmt.Errorf("%s is %w", name, ErrInvalidArticlePerfect)
}

// MustParseArticlePerfect converts a string to a ArticlePerfect, and panics if is not valid.
func MustParseArticlePerfect(name string) ArticlePerfect {
	val, err := ParseArticlePerfect(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticlePerfect) Ptr() *ArticlePerfect {
	return &x
}

const (
	// GetArticleOrderHot is a GetArticleOrder of type hot.
	// 热门
	GetArticleOrderHot GetArticleOrder = "hot"
	// GetArticleOrderGood is a GetArticleOrder of type good.
	// 点赞
	GetArticleOrderGood GetArticleOrder = "good"
	// GetArticleOrderReply is a GetArticleOrder of type reply.
	// 回复
	GetArticleOrderReply GetArticleOrder = "reply"
	// GetArticleOrderPerfect is a GetArticleOrder of type perfect.
	// 精选
	GetArticleOrderPerfect GetArticleOrder = "perfect"
)

var ErrInvalidGetArticleOrder = fmt.Errorf("not a valid GetArticleOrder, try [%s]", strings.Join(_GetArticleOrderNames, ", "))

var _GetArticleOrderNames = []string{
	string(GetArticleOrderHot),
	string(GetArticleOrderGood),
	string(GetArticleOrderReply),
	string(GetArticleOrderPerfect),
}

// GetArticleOrderNames returns a list of possible string values of GetArticleOrder.
func GetArticleOrderNames() []string {
	tmp := make([]string, len(_GetArticleOrderNames))
	copy(tmp, _GetArticleOrderNames)
	return tmp
}

// GetArticleOrderValues returns a list of the values for GetArticleOrder
func GetArticleOrderValues() []GetArticleOrder {
	return []GetArticleOrder{
		GetArticleOrderHot,
		GetArticleOrderGood,
		GetArticleOrderReply,
		GetArticleOrderPerfect,
	}
}

// String implements the Stringer interface.
func (x GetArticleOrder) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GetArticleOrder) IsValid() bool {
	_, err := ParseGetArticleOrder(string(x))
	return err == nil
}

var _GetArticleOrderValue = map[string]GetArticleOrder{
	"hot":     GetArticleOrderHot,
	"good":    GetArticleOrderGood,
	"reply":   GetArticleOrderReply,
	"perfect": GetArticleOrderPerfect,
}

// ParseGetArticleOrder attempts to convert a string to a GetArticleOrder.
func ParseGetArticleOrder(name string) (GetArticleOrder, error) {
	if x, ok := _GetArticleOrderValue[name]; ok {
		return x, nil
	}
	return GetArticleOrder(""), fmt.Errorf("%s is %w", name, ErrInvalidGetArticleOrder)
}

// MustParseGetArticleOrder converts a string to a GetArticleOrder, and panics if is not valid.
func MustParseGetArticleOrder(name string) GetArticleOrder {
	val, err := ParseGetArticleOrder(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x GetArticleOrder) Ptr() *GetArticleOrder {
	return &x
}

const (
	// GetArticleTypeRecent is a GetArticleType of type recent.
	// 最近
	GetArticleTypeRecent GetArticleType = "recent"
	// GetArticleTypeTag is a GetArticleType of type tag.
	// 标签
	GetArticleTypeTag GetArticleType = "tag"
	// GetArticleTypeDomain is a GetArticleType of type domain.
	// 领域
	GetArticleTypeDomain GetArticleType = "domain"
)

var ErrInvalidGetArticleType = fmt.Errorf("not a valid GetArticleType, try [%s]", strings.Join(_GetArticleTypeNames, ", "))

var _GetArticleTypeNames = []string{
	string(GetArticleTypeRecent),
	string(GetArticleTypeTag),
	string(GetArticleTypeDomain),
}

// GetArticleTypeNames returns a list of possible string values of GetArticleType.
func GetArticleTypeNames() []string {
	tmp := make([]string, len(_GetArticleTypeNames))
	copy(tmp, _GetArticleTypeNames)
	return tmp
}

// GetArticleTypeValues returns a list of the values for GetArticleType
func GetArticleTypeValues() []GetArticleType {
	return []GetArticleType{
		GetArticleTypeRecent,
		GetArticleTypeTag,
		GetArticleTypeDomain,
	}
}

// String implements the Stringer interface.
func (x GetArticleType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GetArticleType) IsValid() bool {
	_, err := ParseGetArticleType(string(x))
	return err == nil
}

var _GetArticleTypeValue = map[string]GetArticleType{
	"recent": GetArticleTypeRecent,
	"tag":    GetArticleTypeTag,
	"domain": GetArticleTypeDomain,
}

// ParseGetArticleType attempts to convert a string to a GetArticleType.
func ParseGetArticleType(name string) (GetArticleType, error) {
	if x, ok := _GetArticleTypeValue[name]; ok {
		return x, nil
	}
	return GetArticleType(""), fmt.Errorf("%s is %w", name, ErrInvalidGetArticleType)
}

// MustParseGetArticleType converts a string to a GetArticleType, and panics if is not valid.
func MustParseGetArticleType(name string) GetArticleType {
	val, err := ParseGetArticleType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x GetArticleType) Ptr() *GetArticleType {
	return &x
}

const (
	// VoteResultCancel is a VoteResult of type Cancel.
	// 取消投票
	VoteResultCancel VoteResult = iota
	// VoteResultSuccess is a VoteResult of type Success.
	// 投票成功
	VoteResultSuccess VoteResult = iota + -2
)

var ErrInvalidVoteResult = fmt.Errorf("not a valid VoteResult, try [%s]", strings.Join(_VoteResultNames, ", "))

const _VoteResultName = "cancelsuccess"

var _VoteResultNames = []string{
	_VoteResultName[0:6],
	_VoteResultName[6:13],
}

// VoteResultNames returns a list of possible string values of VoteResult.
func VoteResultNames() []string {
	tmp := make([]string, len(_VoteResultNames))
	copy(tmp, _VoteResultNames)
	return tmp
}

// VoteResultValues returns a list of the values for VoteResult
func VoteResultValues() []VoteResult {
	return []VoteResult{
		VoteResultCancel,
		VoteResultSuccess,
	}
}

var _VoteResultMap = map[VoteResult]string{
	VoteResultCancel:  _VoteResultName[0:6],
	VoteResultSuccess: _VoteResultName[6:13],
}

// String implements the Stringer interface.
func (x VoteResult) String() string {
	if str, ok := _VoteResultMap[x]; ok {
		return str
	}
	return fmt.Sprintf("VoteResult(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VoteResult) IsValid() bool {
	_, ok := _VoteResultMap[x]
	return ok
}

var _VoteResultValue = map[string]VoteResult{
	_VoteResultName[0:6]:  VoteResultCancel,
	_VoteResultName[6:13]: VoteResultSuccess,
}

// ParseVoteResult attempts to convert a string to a VoteResult.
func ParseVoteResult(name string) (VoteResult, error) {
	if x, ok := _VoteResultValue[name]; ok {
		return x, nil
	}
	return VoteResult(0), fmt.Errorf("%s is %w", name, ErrInvalidVoteResult)
}

// MustParseVoteResult converts a string to a VoteResult, and panics if is not valid.
func MustParseVoteResult(name string) VoteResult {
	val, err := ParseVoteResult(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x VoteResult) Ptr() *VoteResult {
	return &x
}
