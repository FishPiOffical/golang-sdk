// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// ArticleListTypeHot is a ArticleListType of type hot.
	// 热门
	ArticleListTypeHot ArticleListType = "hot"
	// ArticleListTypeGood is a ArticleListType of type good.
	// 精华
	ArticleListTypeGood ArticleListType = "good"
	// ArticleListTypePerfect is a ArticleListType of type perfect.
	// 精选
	ArticleListTypePerfect ArticleListType = "perfect"
	// ArticleListTypeReply is a ArticleListType of type reply.
	// 回复
	ArticleListTypeReply ArticleListType = "reply"
)

var ErrInvalidArticleListType = fmt.Errorf("not a valid ArticleListType, try [%s]", strings.Join(_ArticleListTypeNames, ", "))

var _ArticleListTypeNames = []string{
	string(ArticleListTypeHot),
	string(ArticleListTypeGood),
	string(ArticleListTypePerfect),
	string(ArticleListTypeReply),
}

// ArticleListTypeNames returns a list of possible string values of ArticleListType.
func ArticleListTypeNames() []string {
	tmp := make([]string, len(_ArticleListTypeNames))
	copy(tmp, _ArticleListTypeNames)
	return tmp
}

// ArticleListTypeValues returns a list of the values for ArticleListType
func ArticleListTypeValues() []ArticleListType {
	return []ArticleListType{
		ArticleListTypeHot,
		ArticleListTypeGood,
		ArticleListTypePerfect,
		ArticleListTypeReply,
	}
}

// String implements the Stringer interface.
func (x ArticleListType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleListType) IsValid() bool {
	_, err := ParseArticleListType(string(x))
	return err == nil
}

var _ArticleListTypeValue = map[string]ArticleListType{
	"hot":     ArticleListTypeHot,
	"good":    ArticleListTypeGood,
	"perfect": ArticleListTypePerfect,
	"reply":   ArticleListTypeReply,
}

// ParseArticleListType attempts to convert a string to a ArticleListType.
func ParseArticleListType(name string) (ArticleListType, error) {
	if x, ok := _ArticleListTypeValue[name]; ok {
		return x, nil
	}
	return ArticleListType(""), fmt.Errorf("%s is %w", name, ErrInvalidArticleListType)
}

// MustParseArticleListType converts a string to a ArticleListType, and panics if is not valid.
func MustParseArticleListType(name string) ArticleListType {
	val, err := ParseArticleListType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleListType) Ptr() *ArticleListType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticleListType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticleListType) UnmarshalText(text []byte) error {
	tmp, err := ParseArticleListType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ArticlePerfectYes is a ArticlePerfect of type Yes.
	// 是
	ArticlePerfectYes ArticlePerfect = iota + 1
	// ArticlePerfectNo is a ArticlePerfect of type No.
	// 否
	ArticlePerfectNo ArticlePerfect = iota + -1
)

var ErrInvalidArticlePerfect = fmt.Errorf("not a valid ArticlePerfect, try [%s]", strings.Join(_ArticlePerfectNames, ", "))

const _ArticlePerfectName = "yesno"

var _ArticlePerfectNames = []string{
	_ArticlePerfectName[0:3],
	_ArticlePerfectName[3:5],
}

// ArticlePerfectNames returns a list of possible string values of ArticlePerfect.
func ArticlePerfectNames() []string {
	tmp := make([]string, len(_ArticlePerfectNames))
	copy(tmp, _ArticlePerfectNames)
	return tmp
}

// ArticlePerfectValues returns a list of the values for ArticlePerfect
func ArticlePerfectValues() []ArticlePerfect {
	return []ArticlePerfect{
		ArticlePerfectYes,
		ArticlePerfectNo,
	}
}

var _ArticlePerfectMap = map[ArticlePerfect]string{
	ArticlePerfectYes: _ArticlePerfectName[0:3],
	ArticlePerfectNo:  _ArticlePerfectName[3:5],
}

// String implements the Stringer interface.
func (x ArticlePerfect) String() string {
	if str, ok := _ArticlePerfectMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ArticlePerfect(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticlePerfect) IsValid() bool {
	_, ok := _ArticlePerfectMap[x]
	return ok
}

var _ArticlePerfectValue = map[string]ArticlePerfect{
	_ArticlePerfectName[0:3]: ArticlePerfectYes,
	_ArticlePerfectName[3:5]: ArticlePerfectNo,
}

// ParseArticlePerfect attempts to convert a string to a ArticlePerfect.
func ParseArticlePerfect(name string) (ArticlePerfect, error) {
	if x, ok := _ArticlePerfectValue[name]; ok {
		return x, nil
	}
	return ArticlePerfect(0), fmt.Errorf("%s is %w", name, ErrInvalidArticlePerfect)
}

// MustParseArticlePerfect converts a string to a ArticlePerfect, and panics if is not valid.
func MustParseArticlePerfect(name string) ArticlePerfect {
	val, err := ParseArticlePerfect(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticlePerfect) Ptr() *ArticlePerfect {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticlePerfect) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticlePerfect) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseArticlePerfect(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ArticleTypeNormal is a ArticleType of type Normal.
	// 普通帖子
	ArticleTypeNormal ArticleType = iota
	// ArticleTypeDiscussion is a ArticleType of type Discussion.
	// 讨论区
	ArticleTypeDiscussion
	// ArticleTypeCity is a ArticleType of type City.
	// 同城
	ArticleTypeCity
	// ArticleTypeQna is a ArticleType of type Qna.
	// 问答
	ArticleTypeQna
)

var ErrInvalidArticleType = fmt.Errorf("not a valid ArticleType, try [%s]", strings.Join(_ArticleTypeNames, ", "))

const _ArticleTypeName = "normaldiscussioncityqna"

var _ArticleTypeNames = []string{
	_ArticleTypeName[0:6],
	_ArticleTypeName[6:16],
	_ArticleTypeName[16:20],
	_ArticleTypeName[20:23],
}

// ArticleTypeNames returns a list of possible string values of ArticleType.
func ArticleTypeNames() []string {
	tmp := make([]string, len(_ArticleTypeNames))
	copy(tmp, _ArticleTypeNames)
	return tmp
}

// ArticleTypeValues returns a list of the values for ArticleType
func ArticleTypeValues() []ArticleType {
	return []ArticleType{
		ArticleTypeNormal,
		ArticleTypeDiscussion,
		ArticleTypeCity,
		ArticleTypeQna,
	}
}

var _ArticleTypeMap = map[ArticleType]string{
	ArticleTypeNormal:     _ArticleTypeName[0:6],
	ArticleTypeDiscussion: _ArticleTypeName[6:16],
	ArticleTypeCity:       _ArticleTypeName[16:20],
	ArticleTypeQna:        _ArticleTypeName[20:23],
}

// String implements the Stringer interface.
func (x ArticleType) String() string {
	if str, ok := _ArticleTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ArticleType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleType) IsValid() bool {
	_, ok := _ArticleTypeMap[x]
	return ok
}

var _ArticleTypeValue = map[string]ArticleType{
	_ArticleTypeName[0:6]:   ArticleTypeNormal,
	_ArticleTypeName[6:16]:  ArticleTypeDiscussion,
	_ArticleTypeName[16:20]: ArticleTypeCity,
	_ArticleTypeName[20:23]: ArticleTypeQna,
}

// ParseArticleType attempts to convert a string to a ArticleType.
func ParseArticleType(name string) (ArticleType, error) {
	if x, ok := _ArticleTypeValue[name]; ok {
		return x, nil
	}
	return ArticleType(0), fmt.Errorf("%s is %w", name, ErrInvalidArticleType)
}

// MustParseArticleType converts a string to a ArticleType, and panics if is not valid.
func MustParseArticleType(name string) ArticleType {
	val, err := ParseArticleType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleType) Ptr() *ArticleType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticleType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticleType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseArticleType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
