// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// ArticleChannelOperationIncrease is a ArticleChannelOperation of type increase.
	// 增加
	ArticleChannelOperationIncrease ArticleChannelOperation = "+"
	// ArticleChannelOperationDecrease is a ArticleChannelOperation of type decrease.
	// 减少
	ArticleChannelOperationDecrease ArticleChannelOperation = "-"
)

var ErrInvalidArticleChannelOperation = fmt.Errorf("not a valid ArticleChannelOperation, try [%s]", strings.Join(_ArticleChannelOperationNames, ", "))

var _ArticleChannelOperationNames = []string{
	string(ArticleChannelOperationIncrease),
	string(ArticleChannelOperationDecrease),
}

// ArticleChannelOperationNames returns a list of possible string values of ArticleChannelOperation.
func ArticleChannelOperationNames() []string {
	tmp := make([]string, len(_ArticleChannelOperationNames))
	copy(tmp, _ArticleChannelOperationNames)
	return tmp
}

// ArticleChannelOperationValues returns a list of the values for ArticleChannelOperation
func ArticleChannelOperationValues() []ArticleChannelOperation {
	return []ArticleChannelOperation{
		ArticleChannelOperationIncrease,
		ArticleChannelOperationDecrease,
	}
}

// String implements the Stringer interface.
func (x ArticleChannelOperation) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleChannelOperation) IsValid() bool {
	_, err := ParseArticleChannelOperation(string(x))
	return err == nil
}

var _ArticleChannelOperationValue = map[string]ArticleChannelOperation{
	"+": ArticleChannelOperationIncrease,
	"-": ArticleChannelOperationDecrease,
}

// ParseArticleChannelOperation attempts to convert a string to a ArticleChannelOperation.
func ParseArticleChannelOperation(name string) (ArticleChannelOperation, error) {
	if x, ok := _ArticleChannelOperationValue[name]; ok {
		return x, nil
	}
	return ArticleChannelOperation(""), fmt.Errorf("%s is %w", name, ErrInvalidArticleChannelOperation)
}

// MustParseArticleChannelOperation converts a string to a ArticleChannelOperation, and panics if is not valid.
func MustParseArticleChannelOperation(name string) ArticleChannelOperation {
	val, err := ParseArticleChannelOperation(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleChannelOperation) Ptr() *ArticleChannelOperation {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticleChannelOperation) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticleChannelOperation) UnmarshalText(text []byte) error {
	tmp, err := ParseArticleChannelOperation(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ArticleChannelTypeArticleHeat is a ArticleChannelType of type articleHeat.
	// 文章热度
	ArticleChannelTypeArticleHeat ArticleChannelType = "articleHeat"
)

var ErrInvalidArticleChannelType = fmt.Errorf("not a valid ArticleChannelType, try [%s]", strings.Join(_ArticleChannelTypeNames, ", "))

var _ArticleChannelTypeNames = []string{
	string(ArticleChannelTypeArticleHeat),
}

// ArticleChannelTypeNames returns a list of possible string values of ArticleChannelType.
func ArticleChannelTypeNames() []string {
	tmp := make([]string, len(_ArticleChannelTypeNames))
	copy(tmp, _ArticleChannelTypeNames)
	return tmp
}

// ArticleChannelTypeValues returns a list of the values for ArticleChannelType
func ArticleChannelTypeValues() []ArticleChannelType {
	return []ArticleChannelType{
		ArticleChannelTypeArticleHeat,
	}
}

// String implements the Stringer interface.
func (x ArticleChannelType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ArticleChannelType) IsValid() bool {
	_, err := ParseArticleChannelType(string(x))
	return err == nil
}

var _ArticleChannelTypeValue = map[string]ArticleChannelType{
	"articleHeat": ArticleChannelTypeArticleHeat,
}

// ParseArticleChannelType attempts to convert a string to a ArticleChannelType.
func ParseArticleChannelType(name string) (ArticleChannelType, error) {
	if x, ok := _ArticleChannelTypeValue[name]; ok {
		return x, nil
	}
	return ArticleChannelType(""), fmt.Errorf("%s is %w", name, ErrInvalidArticleChannelType)
}

// MustParseArticleChannelType converts a string to a ArticleChannelType, and panics if is not valid.
func MustParseArticleChannelType(name string) ArticleChannelType {
	val, err := ParseArticleChannelType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ArticleChannelType) Ptr() *ArticleChannelType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ArticleChannelType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ArticleChannelType) UnmarshalText(text []byte) error {
	tmp, err := ParseArticleChannelType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomMsgJsonSubTypeRandom is a ChatroomMsgJsonSubType of type random.
	// 拼手气红包
	ChatroomMsgJsonSubTypeRandom ChatroomMsgJsonSubType = "random"
	// ChatroomMsgJsonSubTypeAverage is a ChatroomMsgJsonSubType of type average.
	// 平分红包
	ChatroomMsgJsonSubTypeAverage ChatroomMsgJsonSubType = "average"
	// ChatroomMsgJsonSubTypeSpecify is a ChatroomMsgJsonSubType of type specify.
	// 专属红包
	ChatroomMsgJsonSubTypeSpecify ChatroomMsgJsonSubType = "specify"
	// ChatroomMsgJsonSubTypeHeartbeat is a ChatroomMsgJsonSubType of type heartbeat.
	// 心跳红包
	ChatroomMsgJsonSubTypeHeartbeat ChatroomMsgJsonSubType = "heartbeat"
	// ChatroomMsgJsonSubTypeRockPaperScissors is a ChatroomMsgJsonSubType of type rockPaperScissors.
	// 猜拳红包
	ChatroomMsgJsonSubTypeRockPaperScissors ChatroomMsgJsonSubType = "rockPaperScissors"
	// ChatroomMsgJsonSubTypeWeather is a ChatroomMsgJsonSubType of type weather.
	// 天气
	ChatroomMsgJsonSubTypeWeather ChatroomMsgJsonSubType = "weather"
	// ChatroomMsgJsonSubTypeMusic is a ChatroomMsgJsonSubType of type music.
	// 音乐
	ChatroomMsgJsonSubTypeMusic ChatroomMsgJsonSubType = "music"
)

var ErrInvalidChatroomMsgJsonSubType = fmt.Errorf("not a valid ChatroomMsgJsonSubType, try [%s]", strings.Join(_ChatroomMsgJsonSubTypeNames, ", "))

var _ChatroomMsgJsonSubTypeNames = []string{
	string(ChatroomMsgJsonSubTypeRandom),
	string(ChatroomMsgJsonSubTypeAverage),
	string(ChatroomMsgJsonSubTypeSpecify),
	string(ChatroomMsgJsonSubTypeHeartbeat),
	string(ChatroomMsgJsonSubTypeRockPaperScissors),
	string(ChatroomMsgJsonSubTypeWeather),
	string(ChatroomMsgJsonSubTypeMusic),
}

// ChatroomMsgJsonSubTypeNames returns a list of possible string values of ChatroomMsgJsonSubType.
func ChatroomMsgJsonSubTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgJsonSubTypeNames))
	copy(tmp, _ChatroomMsgJsonSubTypeNames)
	return tmp
}

// ChatroomMsgJsonSubTypeValues returns a list of the values for ChatroomMsgJsonSubType
func ChatroomMsgJsonSubTypeValues() []ChatroomMsgJsonSubType {
	return []ChatroomMsgJsonSubType{
		ChatroomMsgJsonSubTypeRandom,
		ChatroomMsgJsonSubTypeAverage,
		ChatroomMsgJsonSubTypeSpecify,
		ChatroomMsgJsonSubTypeHeartbeat,
		ChatroomMsgJsonSubTypeRockPaperScissors,
		ChatroomMsgJsonSubTypeWeather,
		ChatroomMsgJsonSubTypeMusic,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgJsonSubType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgJsonSubType) IsValid() bool {
	_, err := ParseChatroomMsgJsonSubType(string(x))
	return err == nil
}

var _ChatroomMsgJsonSubTypeValue = map[string]ChatroomMsgJsonSubType{
	"random":            ChatroomMsgJsonSubTypeRandom,
	"average":           ChatroomMsgJsonSubTypeAverage,
	"specify":           ChatroomMsgJsonSubTypeSpecify,
	"heartbeat":         ChatroomMsgJsonSubTypeHeartbeat,
	"rockPaperScissors": ChatroomMsgJsonSubTypeRockPaperScissors,
	"weather":           ChatroomMsgJsonSubTypeWeather,
	"music":             ChatroomMsgJsonSubTypeMusic,
}

// ParseChatroomMsgJsonSubType attempts to convert a string to a ChatroomMsgJsonSubType.
func ParseChatroomMsgJsonSubType(name string) (ChatroomMsgJsonSubType, error) {
	if x, ok := _ChatroomMsgJsonSubTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgJsonSubType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgJsonSubType)
}

// MustParseChatroomMsgJsonSubType converts a string to a ChatroomMsgJsonSubType, and panics if is not valid.
func MustParseChatroomMsgJsonSubType(name string) ChatroomMsgJsonSubType {
	val, err := ParseChatroomMsgJsonSubType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgJsonSubType) Ptr() *ChatroomMsgJsonSubType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomMsgJsonSubType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomMsgJsonSubType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomMsgJsonSubType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomMsgJsonTypeRedPacket is a ChatroomMsgJsonType of type redPacket.
	// 红包
	ChatroomMsgJsonTypeRedPacket ChatroomMsgJsonType = "redPacket"
	// ChatroomMsgJsonTypeWeather is a ChatroomMsgJsonType of type weather.
	// 天气
	ChatroomMsgJsonTypeWeather ChatroomMsgJsonType = "weather"
	// ChatroomMsgJsonTypeMusic is a ChatroomMsgJsonType of type music.
	// 音乐
	ChatroomMsgJsonTypeMusic ChatroomMsgJsonType = "music"
)

var ErrInvalidChatroomMsgJsonType = fmt.Errorf("not a valid ChatroomMsgJsonType, try [%s]", strings.Join(_ChatroomMsgJsonTypeNames, ", "))

var _ChatroomMsgJsonTypeNames = []string{
	string(ChatroomMsgJsonTypeRedPacket),
	string(ChatroomMsgJsonTypeWeather),
	string(ChatroomMsgJsonTypeMusic),
}

// ChatroomMsgJsonTypeNames returns a list of possible string values of ChatroomMsgJsonType.
func ChatroomMsgJsonTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgJsonTypeNames))
	copy(tmp, _ChatroomMsgJsonTypeNames)
	return tmp
}

// ChatroomMsgJsonTypeValues returns a list of the values for ChatroomMsgJsonType
func ChatroomMsgJsonTypeValues() []ChatroomMsgJsonType {
	return []ChatroomMsgJsonType{
		ChatroomMsgJsonTypeRedPacket,
		ChatroomMsgJsonTypeWeather,
		ChatroomMsgJsonTypeMusic,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgJsonType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgJsonType) IsValid() bool {
	_, err := ParseChatroomMsgJsonType(string(x))
	return err == nil
}

var _ChatroomMsgJsonTypeValue = map[string]ChatroomMsgJsonType{
	"redPacket": ChatroomMsgJsonTypeRedPacket,
	"weather":   ChatroomMsgJsonTypeWeather,
	"music":     ChatroomMsgJsonTypeMusic,
}

// ParseChatroomMsgJsonType attempts to convert a string to a ChatroomMsgJsonType.
func ParseChatroomMsgJsonType(name string) (ChatroomMsgJsonType, error) {
	if x, ok := _ChatroomMsgJsonTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgJsonType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgJsonType)
}

// MustParseChatroomMsgJsonType converts a string to a ChatroomMsgJsonType, and panics if is not valid.
func MustParseChatroomMsgJsonType(name string) ChatroomMsgJsonType {
	val, err := ParseChatroomMsgJsonType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgJsonType) Ptr() *ChatroomMsgJsonType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomMsgJsonType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomMsgJsonType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomMsgJsonType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ChatroomMsgTypeOnline is a ChatroomMsgType of type online.
	// 在线
	ChatroomMsgTypeOnline ChatroomMsgType = "online"
	// ChatroomMsgTypeDiscussChanged is a ChatroomMsgType of type discussChanged.
	// 话题变更
	ChatroomMsgTypeDiscussChanged ChatroomMsgType = "discussChanged"
	// ChatroomMsgTypeRevoke is a ChatroomMsgType of type revoke.
	// 撤回
	ChatroomMsgTypeRevoke ChatroomMsgType = "revoke"
	// ChatroomMsgTypeMsg is a ChatroomMsgType of type msg.
	// 聊天
	ChatroomMsgTypeMsg ChatroomMsgType = "msg"
	// ChatroomMsgTypeRedPacket is a ChatroomMsgType of type redPacket.
	// 红包
	ChatroomMsgTypeRedPacket ChatroomMsgType = "redPacket"
	// ChatroomMsgTypeRedPacketStatus is a ChatroomMsgType of type redPacketStatus.
	// 红包领取
	ChatroomMsgTypeRedPacketStatus ChatroomMsgType = "redPacketStatus"
	// ChatroomMsgTypeCustomMessage is a ChatroomMsgType of type customMessage.
	// 进入离开聊天室消息
	ChatroomMsgTypeCustomMessage ChatroomMsgType = "customMessage"
	// ChatroomMsgTypeBarrager is a ChatroomMsgType of type barrager.
	// 弹幕
	ChatroomMsgTypeBarrager ChatroomMsgType = "barrager"
)

var ErrInvalidChatroomMsgType = fmt.Errorf("not a valid ChatroomMsgType, try [%s]", strings.Join(_ChatroomMsgTypeNames, ", "))

var _ChatroomMsgTypeNames = []string{
	string(ChatroomMsgTypeOnline),
	string(ChatroomMsgTypeDiscussChanged),
	string(ChatroomMsgTypeRevoke),
	string(ChatroomMsgTypeMsg),
	string(ChatroomMsgTypeRedPacket),
	string(ChatroomMsgTypeRedPacketStatus),
	string(ChatroomMsgTypeCustomMessage),
	string(ChatroomMsgTypeBarrager),
}

// ChatroomMsgTypeNames returns a list of possible string values of ChatroomMsgType.
func ChatroomMsgTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgTypeNames))
	copy(tmp, _ChatroomMsgTypeNames)
	return tmp
}

// ChatroomMsgTypeValues returns a list of the values for ChatroomMsgType
func ChatroomMsgTypeValues() []ChatroomMsgType {
	return []ChatroomMsgType{
		ChatroomMsgTypeOnline,
		ChatroomMsgTypeDiscussChanged,
		ChatroomMsgTypeRevoke,
		ChatroomMsgTypeMsg,
		ChatroomMsgTypeRedPacket,
		ChatroomMsgTypeRedPacketStatus,
		ChatroomMsgTypeCustomMessage,
		ChatroomMsgTypeBarrager,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgType) IsValid() bool {
	_, err := ParseChatroomMsgType(string(x))
	return err == nil
}

var _ChatroomMsgTypeValue = map[string]ChatroomMsgType{
	"online":          ChatroomMsgTypeOnline,
	"discussChanged":  ChatroomMsgTypeDiscussChanged,
	"revoke":          ChatroomMsgTypeRevoke,
	"msg":             ChatroomMsgTypeMsg,
	"redPacket":       ChatroomMsgTypeRedPacket,
	"redPacketStatus": ChatroomMsgTypeRedPacketStatus,
	"customMessage":   ChatroomMsgTypeCustomMessage,
	"barrager":        ChatroomMsgTypeBarrager,
}

// ParseChatroomMsgType attempts to convert a string to a ChatroomMsgType.
func ParseChatroomMsgType(name string) (ChatroomMsgType, error) {
	if x, ok := _ChatroomMsgTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgType)
}

// MustParseChatroomMsgType converts a string to a ChatroomMsgType, and panics if is not valid.
func MustParseChatroomMsgType(name string) ChatroomMsgType {
	val, err := ParseChatroomMsgType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgType) Ptr() *ChatroomMsgType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ChatroomMsgType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ChatroomMsgType) UnmarshalText(text []byte) error {
	tmp, err := ParseChatroomMsgType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UserChannelCommandBzUpdate is a UserChannelCommand of type bzUpdate.
	// 清风明月更新
	UserChannelCommandBzUpdate UserChannelCommand = "bzUpdate"
	// UserChannelCommandRefreshNotification is a UserChannelCommand of type refreshNotification.
	// 未读消息数通知
	UserChannelCommandRefreshNotification UserChannelCommand = "refreshNotification"
	// UserChannelCommandChatUnreadCountRefresh is a UserChannelCommand of type chatUnreadCountRefresh.
	// 聊天未读消息数通知
	UserChannelCommandChatUnreadCountRefresh UserChannelCommand = "chatUnreadCountRefresh"
	// UserChannelCommandNewIdleChatMessage is a UserChannelCommand of type newIdleChatMessage.
	// 新的闲聊消息
	UserChannelCommandNewIdleChatMessage UserChannelCommand = "newIdleChatMessage"
	// UserChannelCommandWarnBroadcast is a UserChannelCommand of type warnBroadcast.
	// 警告广播
	UserChannelCommandWarnBroadcast UserChannelCommand = "warnBroadcast"
)

var ErrInvalidUserChannelCommand = fmt.Errorf("not a valid UserChannelCommand, try [%s]", strings.Join(_UserChannelCommandNames, ", "))

var _UserChannelCommandNames = []string{
	string(UserChannelCommandBzUpdate),
	string(UserChannelCommandRefreshNotification),
	string(UserChannelCommandChatUnreadCountRefresh),
	string(UserChannelCommandNewIdleChatMessage),
	string(UserChannelCommandWarnBroadcast),
}

// UserChannelCommandNames returns a list of possible string values of UserChannelCommand.
func UserChannelCommandNames() []string {
	tmp := make([]string, len(_UserChannelCommandNames))
	copy(tmp, _UserChannelCommandNames)
	return tmp
}

// UserChannelCommandValues returns a list of the values for UserChannelCommand
func UserChannelCommandValues() []UserChannelCommand {
	return []UserChannelCommand{
		UserChannelCommandBzUpdate,
		UserChannelCommandRefreshNotification,
		UserChannelCommandChatUnreadCountRefresh,
		UserChannelCommandNewIdleChatMessage,
		UserChannelCommandWarnBroadcast,
	}
}

// String implements the Stringer interface.
func (x UserChannelCommand) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserChannelCommand) IsValid() bool {
	_, err := ParseUserChannelCommand(string(x))
	return err == nil
}

var _UserChannelCommandValue = map[string]UserChannelCommand{
	"bzUpdate":               UserChannelCommandBzUpdate,
	"refreshNotification":    UserChannelCommandRefreshNotification,
	"chatUnreadCountRefresh": UserChannelCommandChatUnreadCountRefresh,
	"newIdleChatMessage":     UserChannelCommandNewIdleChatMessage,
	"warnBroadcast":          UserChannelCommandWarnBroadcast,
}

// ParseUserChannelCommand attempts to convert a string to a UserChannelCommand.
func ParseUserChannelCommand(name string) (UserChannelCommand, error) {
	if x, ok := _UserChannelCommandValue[name]; ok {
		return x, nil
	}
	return UserChannelCommand(""), fmt.Errorf("%s is %w", name, ErrInvalidUserChannelCommand)
}

// MustParseUserChannelCommand converts a string to a UserChannelCommand, and panics if is not valid.
func MustParseUserChannelCommand(name string) UserChannelCommand {
	val, err := ParseUserChannelCommand(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x UserChannelCommand) Ptr() *UserChannelCommand {
	return &x
}

// MarshalText implements the text marshaller method.
func (x UserChannelCommand) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *UserChannelCommand) UnmarshalText(text []byte) error {
	tmp, err := ParseUserChannelCommand(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
