// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// LogInfoTypeSimple is a LogInfoType of type simple.
	// 基础日志
	LogInfoTypeSimple LogInfoType = "simple"
)

var ErrInvalidLogInfoType = fmt.Errorf("not a valid LogInfoType, try [%s]", strings.Join(_LogInfoTypeNames, ", "))

var _LogInfoTypeNames = []string{
	string(LogInfoTypeSimple),
}

// LogInfoTypeNames returns a list of possible string values of LogInfoType.
func LogInfoTypeNames() []string {
	tmp := make([]string, len(_LogInfoTypeNames))
	copy(tmp, _LogInfoTypeNames)
	return tmp
}

// LogInfoTypeValues returns a list of the values for LogInfoType
func LogInfoTypeValues() []LogInfoType {
	return []LogInfoType{
		LogInfoTypeSimple,
	}
}

// String implements the Stringer interface.
func (x LogInfoType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x LogInfoType) IsValid() bool {
	_, err := ParseLogInfoType(string(x))
	return err == nil
}

var _LogInfoTypeValue = map[string]LogInfoType{
	"simple": LogInfoTypeSimple,
}

// ParseLogInfoType attempts to convert a string to a LogInfoType.
func ParseLogInfoType(name string) (LogInfoType, error) {
	if x, ok := _LogInfoTypeValue[name]; ok {
		return x, nil
	}
	return LogInfoType(""), fmt.Errorf("%s is %w", name, ErrInvalidLogInfoType)
}

// MustParseLogInfoType converts a string to a LogInfoType, and panics if is not valid.
func MustParseLogInfoType(name string) LogInfoType {
	val, err := ParseLogInfoType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x LogInfoType) Ptr() *LogInfoType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x LogInfoType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *LogInfoType) UnmarshalText(text []byte) error {
	tmp, err := ParseLogInfoType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportDataTypeArticle is a ReportDataType of type Article.
	// 文章
	ReportDataTypeArticle ReportDataType = iota
	// ReportDataTypeComment is a ReportDataType of type Comment.
	// 评论
	ReportDataTypeComment
	// ReportDataTypeUser is a ReportDataType of type User.
	// 用户
	ReportDataTypeUser
	// ReportDataTypeChatroom is a ReportDataType of type Chatroom.
	// 聊天消息
	ReportDataTypeChatroom
)

var ErrInvalidReportDataType = fmt.Errorf("not a valid ReportDataType, try [%s]", strings.Join(_ReportDataTypeNames, ", "))

const _ReportDataTypeName = "articlecommentuserchatroom"

var _ReportDataTypeNames = []string{
	_ReportDataTypeName[0:7],
	_ReportDataTypeName[7:14],
	_ReportDataTypeName[14:18],
	_ReportDataTypeName[18:26],
}

// ReportDataTypeNames returns a list of possible string values of ReportDataType.
func ReportDataTypeNames() []string {
	tmp := make([]string, len(_ReportDataTypeNames))
	copy(tmp, _ReportDataTypeNames)
	return tmp
}

// ReportDataTypeValues returns a list of the values for ReportDataType
func ReportDataTypeValues() []ReportDataType {
	return []ReportDataType{
		ReportDataTypeArticle,
		ReportDataTypeComment,
		ReportDataTypeUser,
		ReportDataTypeChatroom,
	}
}

var _ReportDataTypeMap = map[ReportDataType]string{
	ReportDataTypeArticle:  _ReportDataTypeName[0:7],
	ReportDataTypeComment:  _ReportDataTypeName[7:14],
	ReportDataTypeUser:     _ReportDataTypeName[14:18],
	ReportDataTypeChatroom: _ReportDataTypeName[18:26],
}

// String implements the Stringer interface.
func (x ReportDataType) String() string {
	if str, ok := _ReportDataTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportDataType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ReportDataType) IsValid() bool {
	_, ok := _ReportDataTypeMap[x]
	return ok
}

var _ReportDataTypeValue = map[string]ReportDataType{
	_ReportDataTypeName[0:7]:   ReportDataTypeArticle,
	_ReportDataTypeName[7:14]:  ReportDataTypeComment,
	_ReportDataTypeName[14:18]: ReportDataTypeUser,
	_ReportDataTypeName[18:26]: ReportDataTypeChatroom,
}

// ParseReportDataType attempts to convert a string to a ReportDataType.
func ParseReportDataType(name string) (ReportDataType, error) {
	if x, ok := _ReportDataTypeValue[name]; ok {
		return x, nil
	}
	return ReportDataType(0), fmt.Errorf("%s is %w", name, ErrInvalidReportDataType)
}

// MustParseReportDataType converts a string to a ReportDataType, and panics if is not valid.
func MustParseReportDataType(name string) ReportDataType {
	val, err := ParseReportDataType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ReportDataType) Ptr() *ReportDataType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ReportDataType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ReportDataType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportDataType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ReportTypeAdvertise is a ReportType of type Advertise.
	// 垃圾广告
	ReportTypeAdvertise ReportType = iota
	// ReportTypePorn is a ReportType of type Porn.
	// 色情
	ReportTypePorn
	// ReportTypeViolate is a ReportType of type Violate.
	// 违规
	ReportTypeViolate
	// ReportTypeInfringement is a ReportType of type Infringement.
	// 侵权
	ReportTypeInfringement
	// ReportTypeAttacks is a ReportType of type Attacks.
	// 人身攻击
	ReportTypeAttacks
	// ReportTypeImpersonate is a ReportType of type Impersonate.
	// 冒充他人账号
	ReportTypeImpersonate
	// ReportTypeAdvertisingAccount is a ReportType of type AdvertisingAccount.
	// 垃圾广告账号
	ReportTypeAdvertisingAccount
	// ReportTypeLeakPrivacy is a ReportType of type LeakPrivacy.
	// 违规泄露个人信息
	ReportTypeLeakPrivacy
	// ReportTypeOther is a ReportType of type Other.
	// 其它
	ReportTypeOther ReportType = iota + 41
)

var ErrInvalidReportType = fmt.Errorf("not a valid ReportType, try [%s]", strings.Join(_ReportTypeNames, ", "))

const _ReportTypeName = "advertisepornviolateinfringementattacksimpersonateadvertisingAccountleakPrivacyother"

var _ReportTypeNames = []string{
	_ReportTypeName[0:9],
	_ReportTypeName[9:13],
	_ReportTypeName[13:20],
	_ReportTypeName[20:32],
	_ReportTypeName[32:39],
	_ReportTypeName[39:50],
	_ReportTypeName[50:68],
	_ReportTypeName[68:79],
	_ReportTypeName[79:84],
}

// ReportTypeNames returns a list of possible string values of ReportType.
func ReportTypeNames() []string {
	tmp := make([]string, len(_ReportTypeNames))
	copy(tmp, _ReportTypeNames)
	return tmp
}

// ReportTypeValues returns a list of the values for ReportType
func ReportTypeValues() []ReportType {
	return []ReportType{
		ReportTypeAdvertise,
		ReportTypePorn,
		ReportTypeViolate,
		ReportTypeInfringement,
		ReportTypeAttacks,
		ReportTypeImpersonate,
		ReportTypeAdvertisingAccount,
		ReportTypeLeakPrivacy,
		ReportTypeOther,
	}
}

var _ReportTypeMap = map[ReportType]string{
	ReportTypeAdvertise:          _ReportTypeName[0:9],
	ReportTypePorn:               _ReportTypeName[9:13],
	ReportTypeViolate:            _ReportTypeName[13:20],
	ReportTypeInfringement:       _ReportTypeName[20:32],
	ReportTypeAttacks:            _ReportTypeName[32:39],
	ReportTypeImpersonate:        _ReportTypeName[39:50],
	ReportTypeAdvertisingAccount: _ReportTypeName[50:68],
	ReportTypeLeakPrivacy:        _ReportTypeName[68:79],
	ReportTypeOther:              _ReportTypeName[79:84],
}

// String implements the Stringer interface.
func (x ReportType) String() string {
	if str, ok := _ReportTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReportType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ReportType) IsValid() bool {
	_, ok := _ReportTypeMap[x]
	return ok
}

var _ReportTypeValue = map[string]ReportType{
	_ReportTypeName[0:9]:   ReportTypeAdvertise,
	_ReportTypeName[9:13]:  ReportTypePorn,
	_ReportTypeName[13:20]: ReportTypeViolate,
	_ReportTypeName[20:32]: ReportTypeInfringement,
	_ReportTypeName[32:39]: ReportTypeAttacks,
	_ReportTypeName[39:50]: ReportTypeImpersonate,
	_ReportTypeName[50:68]: ReportTypeAdvertisingAccount,
	_ReportTypeName[68:79]: ReportTypeLeakPrivacy,
	_ReportTypeName[79:84]: ReportTypeOther,
}

// ParseReportType attempts to convert a string to a ReportType.
func ParseReportType(name string) (ReportType, error) {
	if x, ok := _ReportTypeValue[name]; ok {
		return x, nil
	}
	return ReportType(0), fmt.Errorf("%s is %w", name, ErrInvalidReportType)
}

// MustParseReportType converts a string to a ReportType, and panics if is not valid.
func MustParseReportType(name string) ReportType {
	val, err := ParseReportType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ReportType) Ptr() *ReportType {
	return &x
}

// MarshalText implements the text marshaller method.
func (x ReportType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ReportType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseReportType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
