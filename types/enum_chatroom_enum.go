// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package types

import (
	"fmt"
	"strings"
)

const (
	// ChatContentTypeMd is a ChatContentType of type md.
	// Markdown
	ChatContentTypeMd ChatContentType = "md"
	// ChatContentTypeHtml is a ChatContentType of type html.
	// HTML
	ChatContentTypeHtml ChatContentType = "html"
)

var ErrInvalidChatContentType = fmt.Errorf("not a valid ChatContentType, try [%s]", strings.Join(_ChatContentTypeNames, ", "))

var _ChatContentTypeNames = []string{
	string(ChatContentTypeMd),
	string(ChatContentTypeHtml),
}

// ChatContentTypeNames returns a list of possible string values of ChatContentType.
func ChatContentTypeNames() []string {
	tmp := make([]string, len(_ChatContentTypeNames))
	copy(tmp, _ChatContentTypeNames)
	return tmp
}

// ChatContentTypeValues returns a list of the values for ChatContentType
func ChatContentTypeValues() []ChatContentType {
	return []ChatContentType{
		ChatContentTypeMd,
		ChatContentTypeHtml,
	}
}

// String implements the Stringer interface.
func (x ChatContentType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatContentType) IsValid() bool {
	_, err := ParseChatContentType(string(x))
	return err == nil
}

var _ChatContentTypeValue = map[string]ChatContentType{
	"md":   ChatContentTypeMd,
	"html": ChatContentTypeHtml,
}

// ParseChatContentType attempts to convert a string to a ChatContentType.
func ParseChatContentType(name string) (ChatContentType, error) {
	if x, ok := _ChatContentTypeValue[name]; ok {
		return x, nil
	}
	return ChatContentType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatContentType)
}

// MustParseChatContentType converts a string to a ChatContentType, and panics if is not valid.
func MustParseChatContentType(name string) ChatContentType {
	val, err := ParseChatContentType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatContentType) Ptr() *ChatContentType {
	return &x
}

const (
	// ChatMessageTypeContext is a ChatMessageType of type Context.
	// 上下文
	ChatMessageTypeContext ChatMessageType = iota
	// ChatMessageTypeBefore is a ChatMessageType of type Before.
	// 之前
	ChatMessageTypeBefore
	// ChatMessageTypeAfter is a ChatMessageType of type After.
	// 之后
	ChatMessageTypeAfter
)

var ErrInvalidChatMessageType = fmt.Errorf("not a valid ChatMessageType, try [%s]", strings.Join(_ChatMessageTypeNames, ", "))

const _ChatMessageTypeName = "contextbeforeafter"

var _ChatMessageTypeNames = []string{
	_ChatMessageTypeName[0:7],
	_ChatMessageTypeName[7:13],
	_ChatMessageTypeName[13:18],
}

// ChatMessageTypeNames returns a list of possible string values of ChatMessageType.
func ChatMessageTypeNames() []string {
	tmp := make([]string, len(_ChatMessageTypeNames))
	copy(tmp, _ChatMessageTypeNames)
	return tmp
}

// ChatMessageTypeValues returns a list of the values for ChatMessageType
func ChatMessageTypeValues() []ChatMessageType {
	return []ChatMessageType{
		ChatMessageTypeContext,
		ChatMessageTypeBefore,
		ChatMessageTypeAfter,
	}
}

var _ChatMessageTypeMap = map[ChatMessageType]string{
	ChatMessageTypeContext: _ChatMessageTypeName[0:7],
	ChatMessageTypeBefore:  _ChatMessageTypeName[7:13],
	ChatMessageTypeAfter:   _ChatMessageTypeName[13:18],
}

// String implements the Stringer interface.
func (x ChatMessageType) String() string {
	if str, ok := _ChatMessageTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ChatMessageType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatMessageType) IsValid() bool {
	_, ok := _ChatMessageTypeMap[x]
	return ok
}

var _ChatMessageTypeValue = map[string]ChatMessageType{
	_ChatMessageTypeName[0:7]:   ChatMessageTypeContext,
	_ChatMessageTypeName[7:13]:  ChatMessageTypeBefore,
	_ChatMessageTypeName[13:18]: ChatMessageTypeAfter,
}

// ParseChatMessageType attempts to convert a string to a ChatMessageType.
func ParseChatMessageType(name string) (ChatMessageType, error) {
	if x, ok := _ChatMessageTypeValue[name]; ok {
		return x, nil
	}
	return ChatMessageType(0), fmt.Errorf("%s is %w", name, ErrInvalidChatMessageType)
}

// MustParseChatMessageType converts a string to a ChatMessageType, and panics if is not valid.
func MustParseChatMessageType(name string) ChatMessageType {
	val, err := ParseChatMessageType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatMessageType) Ptr() *ChatMessageType {
	return &x
}

const (
	// ChatroomMsgTypeOnline is a ChatroomMsgType of type online.
	// 在线
	ChatroomMsgTypeOnline ChatroomMsgType = "online"
	// ChatroomMsgTypeDiscussChanged is a ChatroomMsgType of type discussChanged.
	// 话题变更
	ChatroomMsgTypeDiscussChanged ChatroomMsgType = "discussChanged"
	// ChatroomMsgTypeRevoke is a ChatroomMsgType of type revoke.
	// 撤回
	ChatroomMsgTypeRevoke ChatroomMsgType = "revoke"
	// ChatroomMsgTypeMsg is a ChatroomMsgType of type msg.
	// 聊天
	ChatroomMsgTypeMsg ChatroomMsgType = "msg"
	// ChatroomMsgTypeRedPacket is a ChatroomMsgType of type redPacket.
	// 红包
	ChatroomMsgTypeRedPacket ChatroomMsgType = "redPacket"
	// ChatroomMsgTypeRedPacketStatus is a ChatroomMsgType of type redPacketStatus.
	// 红包领取
	ChatroomMsgTypeRedPacketStatus ChatroomMsgType = "redPacketStatus"
	// ChatroomMsgTypeCustomMessage is a ChatroomMsgType of type customMessage.
	// 进入离开聊天室消息
	ChatroomMsgTypeCustomMessage ChatroomMsgType = "customMessage"
	// ChatroomMsgTypeBarrager is a ChatroomMsgType of type barrager.
	// 弹幕
	ChatroomMsgTypeBarrager ChatroomMsgType = "barrager"
)

var ErrInvalidChatroomMsgType = fmt.Errorf("not a valid ChatroomMsgType, try [%s]", strings.Join(_ChatroomMsgTypeNames, ", "))

var _ChatroomMsgTypeNames = []string{
	string(ChatroomMsgTypeOnline),
	string(ChatroomMsgTypeDiscussChanged),
	string(ChatroomMsgTypeRevoke),
	string(ChatroomMsgTypeMsg),
	string(ChatroomMsgTypeRedPacket),
	string(ChatroomMsgTypeRedPacketStatus),
	string(ChatroomMsgTypeCustomMessage),
	string(ChatroomMsgTypeBarrager),
}

// ChatroomMsgTypeNames returns a list of possible string values of ChatroomMsgType.
func ChatroomMsgTypeNames() []string {
	tmp := make([]string, len(_ChatroomMsgTypeNames))
	copy(tmp, _ChatroomMsgTypeNames)
	return tmp
}

// ChatroomMsgTypeValues returns a list of the values for ChatroomMsgType
func ChatroomMsgTypeValues() []ChatroomMsgType {
	return []ChatroomMsgType{
		ChatroomMsgTypeOnline,
		ChatroomMsgTypeDiscussChanged,
		ChatroomMsgTypeRevoke,
		ChatroomMsgTypeMsg,
		ChatroomMsgTypeRedPacket,
		ChatroomMsgTypeRedPacketStatus,
		ChatroomMsgTypeCustomMessage,
		ChatroomMsgTypeBarrager,
	}
}

// String implements the Stringer interface.
func (x ChatroomMsgType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomMsgType) IsValid() bool {
	_, err := ParseChatroomMsgType(string(x))
	return err == nil
}

var _ChatroomMsgTypeValue = map[string]ChatroomMsgType{
	"online":          ChatroomMsgTypeOnline,
	"discussChanged":  ChatroomMsgTypeDiscussChanged,
	"revoke":          ChatroomMsgTypeRevoke,
	"msg":             ChatroomMsgTypeMsg,
	"redPacket":       ChatroomMsgTypeRedPacket,
	"redPacketStatus": ChatroomMsgTypeRedPacketStatus,
	"customMessage":   ChatroomMsgTypeCustomMessage,
	"barrager":        ChatroomMsgTypeBarrager,
}

// ParseChatroomMsgType attempts to convert a string to a ChatroomMsgType.
func ParseChatroomMsgType(name string) (ChatroomMsgType, error) {
	if x, ok := _ChatroomMsgTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomMsgType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomMsgType)
}

// MustParseChatroomMsgType converts a string to a ChatroomMsgType, and panics if is not valid.
func MustParseChatroomMsgType(name string) ChatroomMsgType {
	val, err := ParseChatroomMsgType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomMsgType) Ptr() *ChatroomMsgType {
	return &x
}

const (
	// ChatroomRedPacketTypeRandom is a ChatroomRedPacketType of type random.
	// 拼手气红包
	ChatroomRedPacketTypeRandom ChatroomRedPacketType = "random"
	// ChatroomRedPacketTypeAverage is a ChatroomRedPacketType of type average.
	// 平分红包
	ChatroomRedPacketTypeAverage ChatroomRedPacketType = "average"
	// ChatroomRedPacketTypeSpecify is a ChatroomRedPacketType of type specify.
	// 专属红包
	ChatroomRedPacketTypeSpecify ChatroomRedPacketType = "specify"
	// ChatroomRedPacketTypeHeartbeat is a ChatroomRedPacketType of type heartbeat.
	// 心跳红包
	ChatroomRedPacketTypeHeartbeat ChatroomRedPacketType = "heartbeat"
	// ChatroomRedPacketTypeRockPaperScissors is a ChatroomRedPacketType of type rockPaperScissors.
	// 猜拳红包
	ChatroomRedPacketTypeRockPaperScissors ChatroomRedPacketType = "rockPaperScissors"
)

var ErrInvalidChatroomRedPacketType = fmt.Errorf("not a valid ChatroomRedPacketType, try [%s]", strings.Join(_ChatroomRedPacketTypeNames, ", "))

var _ChatroomRedPacketTypeNames = []string{
	string(ChatroomRedPacketTypeRandom),
	string(ChatroomRedPacketTypeAverage),
	string(ChatroomRedPacketTypeSpecify),
	string(ChatroomRedPacketTypeHeartbeat),
	string(ChatroomRedPacketTypeRockPaperScissors),
}

// ChatroomRedPacketTypeNames returns a list of possible string values of ChatroomRedPacketType.
func ChatroomRedPacketTypeNames() []string {
	tmp := make([]string, len(_ChatroomRedPacketTypeNames))
	copy(tmp, _ChatroomRedPacketTypeNames)
	return tmp
}

// ChatroomRedPacketTypeValues returns a list of the values for ChatroomRedPacketType
func ChatroomRedPacketTypeValues() []ChatroomRedPacketType {
	return []ChatroomRedPacketType{
		ChatroomRedPacketTypeRandom,
		ChatroomRedPacketTypeAverage,
		ChatroomRedPacketTypeSpecify,
		ChatroomRedPacketTypeHeartbeat,
		ChatroomRedPacketTypeRockPaperScissors,
	}
}

// String implements the Stringer interface.
func (x ChatroomRedPacketType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ChatroomRedPacketType) IsValid() bool {
	_, err := ParseChatroomRedPacketType(string(x))
	return err == nil
}

var _ChatroomRedPacketTypeValue = map[string]ChatroomRedPacketType{
	"random":            ChatroomRedPacketTypeRandom,
	"average":           ChatroomRedPacketTypeAverage,
	"specify":           ChatroomRedPacketTypeSpecify,
	"heartbeat":         ChatroomRedPacketTypeHeartbeat,
	"rockPaperScissors": ChatroomRedPacketTypeRockPaperScissors,
}

// ParseChatroomRedPacketType attempts to convert a string to a ChatroomRedPacketType.
func ParseChatroomRedPacketType(name string) (ChatroomRedPacketType, error) {
	if x, ok := _ChatroomRedPacketTypeValue[name]; ok {
		return x, nil
	}
	return ChatroomRedPacketType(""), fmt.Errorf("%s is %w", name, ErrInvalidChatroomRedPacketType)
}

// MustParseChatroomRedPacketType converts a string to a ChatroomRedPacketType, and panics if is not valid.
func MustParseChatroomRedPacketType(name string) ChatroomRedPacketType {
	val, err := ParseChatroomRedPacketType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x ChatroomRedPacketType) Ptr() *ChatroomRedPacketType {
	return &x
}

const (
	// CloudGameIdEmojis is a CloudGameId of type emojis.
	// 表情包
	CloudGameIdEmojis CloudGameId = "emojis"
)

var ErrInvalidCloudGameId = fmt.Errorf("not a valid CloudGameId, try [%s]", strings.Join(_CloudGameIdNames, ", "))

var _CloudGameIdNames = []string{
	string(CloudGameIdEmojis),
}

// CloudGameIdNames returns a list of possible string values of CloudGameId.
func CloudGameIdNames() []string {
	tmp := make([]string, len(_CloudGameIdNames))
	copy(tmp, _CloudGameIdNames)
	return tmp
}

// CloudGameIdValues returns a list of the values for CloudGameId
func CloudGameIdValues() []CloudGameId {
	return []CloudGameId{
		CloudGameIdEmojis,
	}
}

// String implements the Stringer interface.
func (x CloudGameId) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CloudGameId) IsValid() bool {
	_, err := ParseCloudGameId(string(x))
	return err == nil
}

var _CloudGameIdValue = map[string]CloudGameId{
	"emojis": CloudGameIdEmojis,
}

// ParseCloudGameId attempts to convert a string to a CloudGameId.
func ParseCloudGameId(name string) (CloudGameId, error) {
	if x, ok := _CloudGameIdValue[name]; ok {
		return x, nil
	}
	return CloudGameId(""), fmt.Errorf("%s is %w", name, ErrInvalidCloudGameId)
}

// MustParseCloudGameId converts a string to a CloudGameId, and panics if is not valid.
func MustParseCloudGameId(name string) CloudGameId {
	val, err := ParseCloudGameId(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x CloudGameId) Ptr() *CloudGameId {
	return &x
}

const (
	// GestureTypeRock is a GestureType of type Rock.
	// 石头
	GestureTypeRock GestureType = iota
	// GestureTypeScissors is a GestureType of type Scissors.
	// 剪刀
	GestureTypeScissors
	// GestureTypePaper is a GestureType of type Paper.
	// 布
	GestureTypePaper
)

var ErrInvalidGestureType = fmt.Errorf("not a valid GestureType, try [%s]", strings.Join(_GestureTypeNames, ", "))

const _GestureTypeName = "rockscissorspaper"

var _GestureTypeNames = []string{
	_GestureTypeName[0:4],
	_GestureTypeName[4:12],
	_GestureTypeName[12:17],
}

// GestureTypeNames returns a list of possible string values of GestureType.
func GestureTypeNames() []string {
	tmp := make([]string, len(_GestureTypeNames))
	copy(tmp, _GestureTypeNames)
	return tmp
}

// GestureTypeValues returns a list of the values for GestureType
func GestureTypeValues() []GestureType {
	return []GestureType{
		GestureTypeRock,
		GestureTypeScissors,
		GestureTypePaper,
	}
}

var _GestureTypeMap = map[GestureType]string{
	GestureTypeRock:     _GestureTypeName[0:4],
	GestureTypeScissors: _GestureTypeName[4:12],
	GestureTypePaper:    _GestureTypeName[12:17],
}

// String implements the Stringer interface.
func (x GestureType) String() string {
	if str, ok := _GestureTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("GestureType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x GestureType) IsValid() bool {
	_, ok := _GestureTypeMap[x]
	return ok
}

var _GestureTypeValue = map[string]GestureType{
	_GestureTypeName[0:4]:   GestureTypeRock,
	_GestureTypeName[4:12]:  GestureTypeScissors,
	_GestureTypeName[12:17]: GestureTypePaper,
}

// ParseGestureType attempts to convert a string to a GestureType.
func ParseGestureType(name string) (GestureType, error) {
	if x, ok := _GestureTypeValue[name]; ok {
		return x, nil
	}
	return GestureType(0), fmt.Errorf("%s is %w", name, ErrInvalidGestureType)
}

// MustParseGestureType converts a string to a GestureType, and panics if is not valid.
func MustParseGestureType(name string) GestureType {
	val, err := ParseGestureType(name)
	if err != nil {
		panic(err)
	}
	return val
}

func (x GestureType) Ptr() *GestureType {
	return &x
}
